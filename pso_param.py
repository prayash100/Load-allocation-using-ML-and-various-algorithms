import numpy as np
import random

# Define initial capacities
renewable_capacity = {'solar': 100, 'wind': 150}  # MW
conventional_capacity = {'coal': 200, 'gas': 100}  # MW

# Fluctuating load demand generator
def generate_fluctuating_load(base_load, fluctuation_range=50):
    # Simulate load fluctuation by adding or subtracting a random value
    load_variation = random.uniform(-fluctuation_range, fluctuation_range)
    fluctuating_load = base_load + load_variation
    return max(0, fluctuating_load)  # Ensure load is never negative

# Define the PSO algorithm with adjustable parameters
def particle_swarm_optimization(renewable_capacity, conventional_capacity, load_demand, iterations, swarm_size, inertia_weight, cognitive_weight, social_weight):
    swarm = np.random.rand(swarm_size, 4) * [renewable_capacity['solar'], renewable_capacity['wind'], conventional_capacity['coal'], conventional_capacity['gas']]
    velocities = np.zeros_like(swarm)
    best_positions = np.copy(swarm)
    best_deviation = np.inf * np.ones(swarm_size)
    
    global_best_position = best_positions[0]
    global_best_deviation = np.inf

    for _ in range(iterations):
        fluctuating_load = generate_fluctuating_load(load_demand)  # Update load demand dynamically
        for i in range(swarm_size):
            solar_output, wind_output, coal_output, gas_output = swarm[i]
            frequency_deviation = grid_frequency(solar_output, wind_output, coal_output, gas_output, fluctuating_load)

            # Update best positions based on the current frequency deviation
            if abs(frequency_deviation) < best_deviation[i]:
                best_positions[i] = swarm[i]
                best_deviation[i] = abs(frequency_deviation)

            if abs(frequency_deviation) < global_best_deviation:
                global_best_position = swarm[i]
                global_best_deviation = abs(frequency_deviation)
        
        # Update velocities and positions based on PSO parameters
        for i in range(swarm_size):
            velocities[i] = inertia_weight * velocities[i] + \
                            cognitive_weight * np.random.rand() * (best_positions[i] - swarm[i]) + \
                            social_weight * np.random.rand() * (global_best_position - swarm[i])
            swarm[i] = swarm[i] + velocities[i]
            swarm[i] = np.clip(swarm[i], 0, [renewable_capacity['solar'], renewable_capacity['wind'], conventional_capacity['coal'], conventional_capacity['gas']])

    return global_best_position

def grid_frequency(solar_output, wind_output, coal_output, gas_output, load_demand):
    """
    Calculate the frequency deviation of the grid based on the power generation outputs
    and the fluctuating load demand.
    
    Args:
    - solar_output (float): Power generated by solar in MW
    - wind_output (float): Power generated by wind in MW
    - coal_output (float): Power generated by coal in MW
    - gas_output (float): Power generated by gas in MW
    - load_demand (float): Current load demand in MW
    
    Returns:
    - float: The frequency deviation in Hz
    """
    # Total power generated
    total_generation = solar_output + wind_output + coal_output + gas_output
    
    # Frequency deviation is based on the difference between total generation and load demand
    # Assuming a simple linear relationship where deviation increases with mismatch
    deviation = total_generation - load_demand
    
    # Assuming the frequency deviation (in Hz) is proportional to the generation mismatch
    # A typical range for frequency deviation in power grids is around Â±0.5 Hz for small mismatches
    frequency_deviation = deviation * 0.01  # You may need to adjust this factor based on your model
    
    return frequency_deviation

# Define cost calculation function
def calculate_total_cost(solar_output, wind_output, coal_output, gas_output):
    solar_cost = 0.05 * solar_output
    wind_cost = 0.07 * wind_output
    coal_cost = 0.1 * coal_output
    gas_cost = 0.08 * gas_output
    return solar_cost + wind_cost + coal_cost + gas_cost

# Grid search for fine-tuning PSO parameters
def fine_tune_pso_parameters():
    best_cost = np.inf
    best_params = None
    
    # Hyperparameter ranges for tuning
    inertia_weights = [0.4, 0.5, 0.6, 0.7, 0.8,0.9,1.0]
    cognitive_weights = [1.2, 1.3, 1.4, 1.5, 1.6,1.7,1.8]
    social_weights = [1.2, 1.3, 1.4, 1.5, 1.6,1.7,1.8]

    # Run the optimization process for 100 iterations
    for inertia_weight in inertia_weights:
        for cognitive_weight in cognitive_weights:
            for social_weight in social_weights:
                # Run the PSO algorithm for a fixed number of iterations (e.g., 100 iterations)
                pso_result = particle_swarm_optimization(renewable_capacity, conventional_capacity, 250, 100, 50, inertia_weight, cognitive_weight, social_weight)
                # Get the solution's cost
                total_cost = calculate_total_cost(*pso_result)
                
                # Check if the current configuration results in a better cost
                if total_cost < best_cost:
                    best_cost = total_cost
                    best_params = (inertia_weight, cognitive_weight, social_weight)

    return best_params, best_cost

# Run the fine-tuning process
best_params, best_cost = fine_tune_pso_parameters()

print(f"Best PSO Parameters: Inertia Weight = {best_params[0]}, Cognitive Weight = {best_params[1]}, Social Weight = {best_params[2]}")
print(f"Best Total Cost: {best_cost:.2f}")
